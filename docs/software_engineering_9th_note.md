# 《软件工程》原书第 9 版笔记

这个文档包含我个人的理解，对照当时的项目经历产生，按照章节形式组织。

这个文档不保证可读性，是随看随记的。

>  看完这本书之后，根据最近的实际经验，我希望形成一个备忘录——下一次从零开始做项目的时候，每一步我应该做些什么。


第 1 章：概述
===========

不使用软件工程方法开发，通常更简单一些。但是最终结果是费用高而且不可靠。

开发/测试成本（时间？） 6/4。不同的应用可能还要更多。

- 如果瀑布式，我们的测试应该在发布前一半的时间就开始。
- 如果增量开发，我们中间的每个版本应该都能测试通过。

问题：软件越基础，测试成本是不是就越高？

- Ray 的成本很大一部分在测试成本。想要做一个 ray 的组件并且达到他的稳定性，比看起来困难得多。

软件包括所有文档和配置信息。


第 2 章：软件过程
===============

> 基本过程：描述，开发，验证，演化。不同的方法顺序不同。

核心需求和体系结构是不能增量式开发的。基本不能。

很难提前描述好的部分，比如用户界面，就需要增量式开发。

瀑布式开发，每个阶段不可避免地要冻结一些问题，因为从各个阶段之间反复是成本很高的。

- 就像现在冻结了一些功能，留待以后实现。但是整个系统就是堪堪能够使用的程度。

增量式方法的问题：

1. 过程不透明。很难通过文档把握进度。
2. 需要定期维护系统结构。否则添加功能就会越来越难。

面向复用的开发——我们试图复用 Ray 的分布式能力。

- 问题：我自己开发的组件很不稳定。
  - Ray 除了开发成本，更大的部分是测试成本。
  - 我们没有付出这个测试成本，之前没有考虑到。因此软件是做出来了，但是没办法投入使用。

极限编程，测试先于开发的好处，不仅是理解需求，而且保证不会因为写测试而推迟交付。

应对变更的做法：先做个原型检验需求，或者增量地交付软件。

- Ray 本来可以成为一个好的原型工具的。
- 设计的过程我付出的努力过少了。

另外还有一点更重要的，我几乎没有对任何事提出“强烈的反对意见”。

- 这意味着我也没有用我 100% 的努力去“证明某件事是对的”。
- 人少的时候，没有纯粹的执行者。设计得不好每个人都是有责任的。反过来讲，要求全能。

原型：现在的 0.0.0，最好的定位就是原型——验证需求、探索解决方案的原型。

- 我发现最初的想法是不对的，新增组件的稳定性，需要一个完整的测试体系来支撑。

增量式开发的需求形成过程：

- 先定义需求，再把需求映射到增量，确定了优先级之后，设计体系结构，开发，每走一步都要验证。
- 本来可以增量式开发的。基于 ray python 的弹性 DP - 尝试 hack ray 来全局调度，当时会更容易察觉到问题。

风险管理：Boehm 的螺旋模型。

- 软件开发的每一个阶段都有风险。这次原型开发过程中，我们就没有采取好的策略，来控制风险。
- 风险就是出问题的可能性。比如选择一个新的编译器、语言。
  - 我们的风险：使用 ray。hack ray 能否实现我们的功能。能否达到 serving 级别的可靠性。Pure ray 实现的效率可能不存在问题。

需求有两种：用户需求和系统需求。

- 用户角度，用户需要实现一个什么样的系统，高度抽象，和实现不应该绑定
- 系统需求详细描述，系统需要提供的功能。
- 先有用户需求，后有系统需求。系统需求应该尽可能灵活地支持用户需求。

为啥不拿原型发布？

- 原型会忽略性能、安全性和可靠性需求。这些不好加。
- 反过来，原型之所以为原型，就是可以忽略这些来加快速度。

螺旋模型：一圈一个目标，所有方案，所有风险。

- 风险：超期、超支。

RUP说明，一个好的迭代式软件开发过程需要：

- factors：需求 - 功能 - 风险
- 需求：记录需求，跟踪需求，排需求优先级。接受需求之前分析带来的影响。
  - 我们没有一个跟踪需求的看板。
- 功能：开发功能，测试功能是否满足用户需求&系统需求，正确部署到生产环境。
- 风险：超期、超支、软件功能不能正常工作。

第 3 章：敏捷软件开发
==================

针对长周期、大工程的计划方法，投入到小工程里，就会让小工程的计划成本大于实际开发、测试的成本。所以不是很合适。所以会有敏捷。

- 客户参与——提供需求，排优先级，评估迭代是否有效
- 增量交付
- 团队成员要密集交流沟通，有时候甚至是非正式的，团队根据情况自己定的流程。
- 不断维护系统的简单性，让它可以维护

一条经验：最重要的文档是系统需求文档。需要增量式地收集需求，并且建立有条理的需求文档。

- 我们的项目：有收集过需求，但是没有建立固定的需求文档，也没有积极地让它随时间更新、演化

我们项目不应该先选择 hack ray cpp。

- 先从阻力最小的路线开始实现，除非确定 performance 可以得到改善，否则不应该选择阻力大的路线。

实习生离职之前，最好能花最后一段时间，几天或者一周，和交接人一起，把他负责的部分重构好。知识蕴藏在代码之中，要确保他走之后，不会影响开发进度。

第 4 章：需求工程
===============

读者不同，导致“需求文档”需要的内容也不同。

- 确定解决方案之前，比如说竞标阶段，需要自然语言概括描述。（用户需求）
- 选择好解决方案之后，需要形式化详细描述。（系统需求）

本章介绍的是非敏捷的需求文档。

极限编程的需求文档：先收集用户使用场景，写在卡片上，然后进行优先级排序。最紧要的进入下一个增量开发环节。

螺旋模型的意思是，可以不用一次就把整个需求做到完全精细，可以不断重复这个过程：

- 需求发现，描述，验证

这是一个不完全结构化，而是以人，人的理解为中心的活动。


第 5 章：系统建模
==============

模型是系统的抽象，而不是它的替代表现，打个比方，是书的目录，而不是逐字翻译版。

5 种图：活动图，用例图，时序图，类图，状态图。

一，早期描述，确定系统的边界。可以使用上下文图+活动图。

UML 活动图例子：非自愿隔离的过程。

- 同步的活动，必须全部执行完成才能进行下一步的活动。

二，交互模型。可以用时序图。

- 用户与系统的交互，用于确定需求
- 系统之间的交互，尽早发现问题

三，系统结构的模型。比如动态的结构模型——交互的线程，和静态的模型——系统组成部分。

四，行为模型。

- 数据流图
- 事件/状态模型

五，该不该拿模型直接转化成代码。

不该的理由：

- 模型支持的抽象和程序的能力不匹配。
- 只有长生命周期的项目，需要考虑可移植性。


第 6 章：体系结构设计
==================

体系结构设计，比起一系列的流程，更像是回答一连串的问题，做出决定。是一个需要创造力的过程。

体系结构视图，Kurtchen 4+1：

- 类和对象，可以弄清楚软件和需求的关系，称为逻辑视图
- 运行时组成系统的进程，可以帮助判断一些非功能特征，比如性能和可用性，称为进程视图
- 模块如何分配给开发团队，称为开发视图
- 软件如何分布在硬件上，可以帮助部署，称为物理视图
- 最常用的框图，称为概念视图

非常好的介绍：[架构设计入门知识 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/153030979)



体系结构模式，下面举几个典型例子：

在数据、数据的表示、数据的操作可以各自独立变化的时候，可以使用 MVC 模式，例如 WEB 服务

需要在已有系统的基础上，一层一层构建新设施的时候，可以使用分层模式，例如 XX 管理系统。

围绕共享数据组织的，可以使用容器（中央数据库）模式，例如 IDE

C/S 模式

流式处理数据的 Pipeline 模式。

第 8 章：软件测试
===============

测试有两个目标：

- 展示满足了需求，称为有效性测试
- 找出缺陷，称为缺陷测试

问题：cpython 库的测试属于哪一类？大部分是缺陷测试吧。

“测试只能证明存在错误，而不能证明错误不存在。”

我们之前写的都是组件测试，忽略了缺陷测试和 benchmark。

- 逐渐增大的，疏于维护的 test 也让缺陷测试没办法进行。

Team own the code, not individual own it. The whole team is responsible.

缺陷测试：系统边界的测试。

发布测试：和开发时的测试不完全相同：

- 应该由一个独立小组负责发布测试
- 开发组的重点是缺陷测试（发现错误），发布的目标是有效性验证测试（没有错误，性能满足）
- 可以基于需求进行测试，需要把测试情况和需求之间做好追踪。
- 也可以基于用户场景做测试，把几个需求组合起来。

- “最终训练代码长什么样” 就是情景测试。

这些最好单独去看一本书。

用户测试：生产环境下的测试。

- alpha：在开发环境中
- beta：在生产环境中
- 接收测试：最终决定部署

第 9 章：软件进化
==============

PEP：正式的变更建议识别、接收、实现和验证。

紧急系统修补常常会降低系统的可用性。

团队交接的问题：

- 敏捷到计划：没有详细文档，交接困难，需要更多交流。
- 计划到敏捷：没有自动化测试，需要一些 re-engineering，提升系统的结构性。

大型软件进化的 Lehman 定律：

1. 必须变更
2. 需要额外资源来保持和简化结构
3. 系统属性，规模，错误数量等，在早期确定且保持不变。确定极限。
4. ......

把软件写得更具有维护性，好处是在整个生命周期中的。

可维护性评估：

1. 修理 bug 的数目增加
2. 一个变更请求影响的组件数增加
3. 实现变更请求的时间变长
4. 一直挂着的变更请求的数量增加

软件成本估计：理解现有代码 + 开发新代码 + 测试整个系统

如何进行软件再工程，书中有一个指南，可以进一步参考。

重构坏味道：冗余代码，长方法，switch，聚集的数据。

- 长达 10 个的参数列表，就是聚集的数据。
- 目前的问题，就是系统质量已经下降了，怎么把它拉回来。
- 目前是低质量，较高的业务价值。

评估遗留系统：

- 高质量，高业务价值
- ...

业务价值高的表现：很多人使用，正常工作对于业务成功很重要。

什么时候选择替换整个系统，而不是继续维护？低质量，低业务价值。


小公司相比于大公司的优势，绝不是在于可以跳过工程规范，而是可以跳过繁文缛节，使工程上最有效的事情，可以正确地实施。

- 小公司更应该注重工程规范。
- Do right thing first, then do something magical. Don't swap the order.



第二部分：可依赖性和信息安全性
========================

第三部分：高级软件工程
==================


第 16 章：软件复用
================

COTS，商业现货产品，所有的桌面软件和很大一部分服务器产品都是。通过配置机制来实现需求。


第 17 章：基于组件的软件工程
========================

90 年代，单个对象的复用遇到了困难——对象有太多细节，太特殊，基本是和应用绑定的。

- 我们试图对 Ray 的对象加以改造，也遇到了同样的困难。

新方法：由接口来完全定义组件，中间件支持组件的集成。

我们项目的 Agent 是一系列组件么？

- 在“由接口”它们可以是，但现在还不是。
- 主要是输入接口，并不明确。
- 整理完接口之后，就可以用组件的方式测试它们。

Component Based SE (CBSE)

完整的组件模型，针对完整的大规模工程，除了接口以外，还有这些要素：

- 唯一标识符、元数据，让它们能够找到彼此。
- 如何部署组件。
- 组件允许被怎么样替换（更新）。
- 组件需要的文档（给人看的）。

目前的组件复用经常发生在机构中，而不是之前畅想的“组件市场”。SAAS 倒是比较常见。

- 服务是完全独立的实体，它没有“需要”接口，不需要使用方实现某个方法。

开发可复用的组件需要注意：

- 接口最好是领域内的稳定抽象，不用经常变。
- 要注意异常处理，异常是接口的一部分，但是不应该有太多。
- 矛盾在于，组件越通用，就包含越多的接口，越难理解
  - Do one thing and do it very well. 这是有其价值的。
  - 这件事不在于组件本身的设计，而在于 protocol 的设计。
    - 也就是说 UNIX 哲学的成功在于字节流IO
    - protocol （数据流）乱七八糟，那想设计 Do one thing 的也做不出来，或者做出来也不能复用。通用性不应该来自组件设计，而在于精心挑选的数据交换方式。

使用可复用的组件需要注意：

- 拿到需求，识别组件，根据组件细化需求，组合
- 这个过程可以循环若干次，也就是说前几次不用太精细，重点是快速反馈。

组件可能产生的问题：不可靠/恶意代码/不需要的功能

- 不需要的功能导致膨胀

第四部分：软件管理
===============


第 22 章：项目管理
===============

风险的主要种类：

- 项目风险：影响项目进度，比如一个程序员走了。
- 产品风险：影响产品性能，比如用的库效率不够。
- 业务风险：影响业务，比如竞品出得早。



风险管理的阶段：

1. 风险识别
2. 风险分析
   - 风险 - 可能性 - 后果评估。
3. 风险规划
4. 风险监控



人员管理，可以单开一本书。一些经验：

- 电子（远程）系统，只有在人们互相认识的情况下使用，才最有效。
  - 创造机会让团队成员直接交流，理解团队。



如何组成高效的技术小组？

- 我经历过的有，每周分享。但是逐渐变成负担。书中的示例是，每隔几个月，以休假的形式组织。


每个人参与到所有阶段来的好处：如果不知道自己的工作在项目中的地位，他们只能按照自己的感觉来。

- eg: 我见到的实习生。


需要一本 XP 的书。

- 非正式小组，需要大部分成员有很好的能力。

第 23 章：项目规划
===============

